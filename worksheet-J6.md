### Question 1
The output was the same every time I compiled and ran the files, except for the first time I did it.

Here is the memory diagram at `//MARK`:
![Memory diagram (please let me know if the image does not appear i.e. I forgot to submit the image to Blackboard)](J6_Q1_Trace.jpeg)

### Question 2 
After adding the sleep statement, the output seems to actually reflect parallel processes-- the print statments alternate (for the most part).

The thread that finishes first changes-- it tends to be the "Good afternoon!" thread (surprisingly, since it starts after than the "Good morning!" thread), but sometimes it's the "Good morning!" thread.

### Question 3
It's possible that the main method is complete but the program is still producing output because the main method is also run in a thread, and as we've discussed, the compiler decides which threads run when. So even though the thread in which main is contained may be done running, the other two threads that were created by main are not done running by the time the thread with main is done running, so they continue to run as prescribed by the OS.

### Question 4
This join statement affects the output of the program by only allowing the thread we join, `morningThread`, to run for the first five seconds, and not the thread in which the `join` call was made. This means that for the five seconds after we join the `morningThread`, _only_ the `morningThread` will be running (since the thread containing main can't get to the `afternoonThread.start()` line and the main thread is the only other active thread, so all we'll see as output for those five seconds are the `Good morning!` print statements generated by `morningThread`.

### Question 5
* `join()` "joins" the thread that it was called on, preventing the thread in which the call was made from running, until the thread which it was called on finishes execution.
* `join(10)` also "joins" the thread it was called on and prevents the thread in which it was called from running while the thread is joined, but the thread can only be joined for a maximum of 10 milliseconds. The thread may finish execution during this time, and in that case, the `join` will simply end there, regardless of whether or not it's been 10 milliseconds.

### Question 6
`isAlive()`, when called on a thread, returns a truth value that corresponds to whether or not the thread it was called on is still running. `join()` makes the thread ***in*** which it was called to wait to continue execution until the thread ***on*** which it was called finishes execution.
